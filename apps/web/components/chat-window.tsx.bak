"use client";

import React, { useMemo, useRef, useEffect, useState, useCallback } from "react";
import { useChat, MessageItem } from "../context/chat-context";
import type { ChatMessage, ModerationActionType } from "@escapehatch/shared";
import { ContextMenu, ContextMenuItem } from "./context-menu";
import { performModerationAction, createReport, uploadMedia } from "../lib/control-plane";
import dynamic from "next/dynamic";

// @ts-ignore - emoji-picker-react types mismatch with Next.js dynamic
const EmojiPicker = dynamic(() => import("emoji-picker-react"), { ssr: false }) as any;
import type { EmojiClickData } from "emoji-picker-react";

interface ChatWindowProps {
    handleSendMessage: (event: React.FormEvent) => Promise<void>;
    handleUpdateSlowMode: (event: React.FormEvent) => Promise<void>;
    handleSetLock: (locked: boolean) => Promise<void>;
    handleMessageListScroll: (event: React.UIEvent<HTMLOListElement>) => void;
    jumpToLatest: () => void;
    submitDraftMessage: () => Promise<void>;
    sendContentWithOptimistic: (content: string, failedId?: string) => Promise<void>;
    handleJoinVoice: () => Promise<void>;
    handleLeaveVoice: () => Promise<void>;
    messagesRef: React.RefObject<HTMLOListElement>;
    messageInputRef: React.RefObject<HTMLTextAreaElement>;
    // UI local states passed down for sync (until moved to context)
    draftMessage: string;
    setDraftMessage: React.Dispatch<React.SetStateAction<string>>;
    sending: boolean;
    voiceConnected: boolean;
    voiceGrant: any; // Type as needed
    mentions: any[]; // Type as needed
    handlePerformModerationAction?: (action: ModerationActionType, targetUserId?: string, targetMessageId?: string) => Promise<void>;
}

function formatMessageTime(value: string): string {
    const date = new Date(value);
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

export function ChatWindow({
    handleSendMessage,
    handleUpdateSlowMode,
    handleSetLock,
    handleMessageListScroll,
    jumpToLatest,
    submitDraftMessage,
    sendContentWithOptimistic,
    handleJoinVoice,
    handleLeaveVoice,
    messagesRef,
    messageInputRef,
    draftMessage,
    setDraftMessage,
    sending,
    voiceConnected,
    voiceGrant,
    mentions
}: ChatWindowProps) {
    const { state, dispatch } = useChat();
    const {
        viewer,
        servers,
        channels,
        selectedServerId,
        selectedChannelId,
        activeChannelData,
        messages,
        isNearBottom,
        pendingNewMessageCount,
        isDetailsOpen,
        theme,
        allowedActions
    } = state;

    const [contextMenu, setContextMenu] = useState<{ x: number; y: number; message: MessageItem | null } | null>(null);
    const [userContextMenu, setUserContextMenu] = useState<{ x: number; y: number; userId: string; displayName: string } | null>(null);
    const [showEmojiPicker, setShowEmojiPicker] = useState(false);
    const [editingMessageId, setEditingMessageId] = useState<string | null>(null);
    const [editContent, setEditContent] = useState("");
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef<HTMLInputElement | null>(null);

    const activeChannel = activeChannelData;

    const activeServer = useMemo(
        () => servers.find((s) => s.id === (activeChannel?.serverId ?? selectedServerId)),
        [servers, selectedServerId, activeChannel?.serverId]
    );

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            const target = event.target as HTMLElement;
            if (showEmojiPicker && !target.closest(".emoji-picker-container") && !target.closest(".composer-trigger")) {
                setShowEmojiPicker(false);
            }
        };

        if (showEmojiPicker) {
            document.addEventListener("mousedown", handleClickOutside);
        }
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [showEmojiPicker]);

    const canManageChannel = useMemo(
        () =>
            allowedActions.includes("channel.lock") ||
            allowedActions.includes("channel.unlock") ||
            allowedActions.includes("channel.slowmode"),
        [allowedActions]
    );

    const renderedMessages = useMemo(() => {
        const grouped: Array<{
            message: MessageItem;
            showHeader: boolean;
            showDateDivider: boolean;
        }> = [];

        for (let index = 0; index < messages.length; index += 1) {
            const message = messages[index]!;
            const previous = messages[index - 1];
            const currentTime = new Date(message.createdAt).getTime();
            const previousTime = previous ? new Date(previous.createdAt).getTime() : null;
            const showHeader =
                !previous ||
                previous.authorUserId !== message.authorUserId ||
                previousTime === null ||
                currentTime - previousTime > 5 * 60 * 1000;

            const showDateDivider =
                !previous ||
                new Date(previous.createdAt).toDateString() !== new Date(message.createdAt).toDateString();

            grouped.push({
                message,
                showHeader,
                showDateDivider
            });
        }

        return grouped;
    }, [messages]);

    const handleContextMenu = (event: React.MouseEvent, message: MessageItem) => {
        event.preventDefault();
        setContextMenu({ x: event.clientX, y: event.clientY, message });
    };

    const isMediaUrl = (url: string) => {
        return /\.(jpeg|jpg|gif|png|webp)$/i.test(url) || /media\.giphy\.com|tenor\.com\/view/i.test(url);
    };

    const extractMediaUrls = (content: string) => {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return content.match(urlRegex)?.filter(isMediaUrl) || [];
    };

    const messageContextMenuItems: ContextMenuItem[] = useMemo(() => {
        if (!contextMenu?.message) return [];
        const isAuthor = contextMenu.message.authorUserId === viewer?.productUserId;
        const isModerator = allowedActions.includes("moderation.kick") || allowedActions.includes("moderation.ban");

        const items: ContextMenuItem[] = [
            {
                label: "Add Reaction",
                icon: "üòÄ",
                onClick: () => {
                    // TODO: Implement reaction picker or quick reactions
                    console.log("Add reaction to", contextMenu.message?.id);
                }
            },
            {
                label: "Copy Text",
                icon: "üìã",
                onClick: () => {
                    void navigator.clipboard.writeText(contextMenu.message?.content || "");
                }
            }
        ];

        if (isAuthor) {
            items.push({
                label: "Edit Message",
                icon: "‚úèÔ∏è",
                onClick: () => {
                    setEditingMessageId(contextMenu.message?.id || null);
                    setEditContent(contextMenu.message?.content || "");
                }
            });
        }

        if (isModerator || isAuthor) {
            items.push({
                label: "Delete Message",
                icon: "üóëÔ∏è",
                danger: true,
                onClick: () => {
                    if (confirm("Are you sure you want to delete this message?")) {
                        void performModerationAction({
                            action: "redact_message",
                            serverId: selectedServerId || "",
                            channelId: selectedChannelId || "",
                            targetMessageId: contextMenu.message?.id,
                            reason: "Manually deleted by user/mod"
                        });
                    }
                }
            });
        }

        if (isModerator && !isAuthor) {
            items.push({
                label: "Timeout User (Shadow Mute)",
                icon: "‚è≥",
                danger: true,
                onClick: () => {
                    void performModerationAction({
                        action: "timeout",
                        serverId: selectedServerId || "",
                        targetUserId: contextMenu.message?.authorUserId,
                        timeoutSeconds: 3600,
                        reason: "Shadow mute requested"
                    });
                }
            });
            items.push({
                label: "Kick User",
                icon: "üë¢",
                danger: true,
                onClick: () => {
                    void performModerationAction({
                        action: "kick",
                        serverId: selectedServerId || "",
                        targetUserId: contextMenu.message?.authorUserId,
                        reason: "Kick requested via message context"
                    });
                }
            });
        }

        return items;
    }, [contextMenu, viewer, allowedActions, selectedServerId, selectedChannelId]);

    const userContextMenuItems: ContextMenuItem[] = useMemo(() => {
        if (!userContextMenu) return [];
        const isModerator = allowedActions.includes("moderation.kick") || allowedActions.includes("moderation.ban");
        const isSelf = userContextMenu.userId === viewer?.productUserId;

        const items: ContextMenuItem[] = [
            {
                label: "View Profile",
                icon: "üë§",
                onClick: () => {
                    // TODO: Implement profile modal
                    console.log("View profile", userContextMenu.userId);
                }
            },
            {
                label: "Direct Message",
                icon: "üí¨",
                onClick: () => {
                    console.log("DM user", userContextMenu.userId);
                }
            }
        ];

        if (!isSelf) {
            items.push({
                label: "Ignore / Block",
                icon: "üö´",
                onClick: () => {
                    console.log("Block user", userContextMenu.userId);
                }
            });
        }

        if (isModerator && !isSelf) {
            items.push({
                label: "Timeout (Shadow Mute)",
                icon: "‚è≥",
                danger: true,
                onClick: () => {
                    void performModerationAction({
                        action: "timeout",
                        serverId: selectedServerId || "",
                        targetUserId: userContextMenu.userId,
                        timeoutSeconds: 3600,
                        reason: "Shadow mute requested via message user"
                    });
                }
            });
            items.push({
                label: "Kick",
                icon: "üë¢",
                danger: true,
                onClick: () => {
                    void performModerationAction({
                        action: "kick",
                        serverId: selectedServerId || "",
                        targetUserId: userContextMenu.userId,
                        reason: "Kick requested via message user"
                    });
                }
            });
        }

        return items;
    }, [userContextMenu, viewer, allowedActions, selectedServerId]);

    const handleUserContextMenu = (event: React.MouseEvent, userId: string, displayName: string) => {
        event.preventDefault();
        event.stopPropagation();
        setUserContextMenu({ x: event.clientX, y: event.clientY, userId, displayName });
    };

    const handleFileUpload = async (files: FileList | null) => {
        if (!files || files.length === 0) return;
        const file = files.item(0);
        if (!file) return;
        if (!file.type.startsWith("image/")) {
            alert("Only images are supported.");
            return;
        }
        if (!activeServer?.id) {
            alert("Please select a server first.");
            return;
        }

        setIsUploading(true);
        try {
            const { url } = await uploadMedia(activeServer.id, file);
            setDraftMessage((prev) => (prev ? `${prev}\n![image](${url})` : `![image](${url})`));
        } catch (error) {
            console.error("Upload failed", error);
            alert("Failed to upload image.");
        } finally {
            setIsUploading(false);
            if (fileInputRef.current) {
                fileInputRef.current.value = "";
            }
        }
    };

    const handlePaste = (e: React.ClipboardEvent) => {
        if (e.clipboardData.files && e.clipboardData.files.length > 0) {
            e.preventDefault();
            void handleFileUpload(e.clipboardData.files);
        }
    };

    const handleDrop = (e: React.DragEvent) => {
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            e.preventDefault();
            const hasImage = Array.from(e.dataTransfer.files).some((f) => f.type.startsWith("image/"));
            if (hasImage) {
                void handleFileUpload(e.dataTransfer.files);
            }
        }
    };

    const handleDragOver = (e: React.DragEvent) => {
        e.preventDefault(); // needed to allow drop
    };

    return (
        <section
            className="timeline panel"
            aria-label="Messages"
            onDrop={handleDrop}
            onDragOver={handleDragOver}
        >
            <header className="channel-header">
                <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
                    <button
                        type="button"
                        className="icon-button mobile-only"
                        onClick={() => dispatch({ type: "SET_SIDEBAR_OPEN", payload: !state.isSidebarOpen })}
                        aria-label="Toggle Sidebar"
                        style={{ display: "none" }} /* Hidden by CSS for desktop */
                    >
                        ‚ò∞
                    </button>
                    <div>
                        <h2>{activeServer ? `${activeServer.name} - ` : ""}{activeChannel ? `#${activeChannel.name}` : "No channel selected"}</h2>
                        <p>
                            {activeChannel
                                ? `${messages.length} messages ¬∑ slow mode ${activeChannel.slowModeSeconds}s`
                                : "Select a channel to start chatting"}
                        </p>
                    </div>
                </div>
                <div className="channel-actions">
                    <span className="channel-badge">{activeChannel?.type ?? "none"}</span>

                    <button
                        type="button"
                        className="ghost"
                        title={isDetailsOpen ? "Hide Details" : "Show Details"}
                        onClick={() => dispatch({ type: "SET_DETAILS_OPEN", payload: !isDetailsOpen })}
                    >
                        {isDetailsOpen ? "‚Üí" : "‚Üê"}
                    </button>
                </div>
            </header>


            <ol className="messages" ref={messagesRef} onScroll={handleMessageListScroll}>
                {renderedMessages.map(({ message, showHeader, showDateDivider }) => {
                    const mediaUrls = extractMediaUrls(message.content);
                    return (
                        <li key={message.id}>
                            {showDateDivider ? (
                                <div className="date-divider">
                                    <span>{new Date(message.createdAt).toLocaleDateString()}</span>
                                </div>
                            ) : null}
                            <article onContextMenu={(e) => handleContextMenu(e, message)}>
                                {showHeader ? (
                                    <header>
                                        <strong
                                            className="author-name"
                                            style={{ cursor: "pointer" }}
                                            onClick={(e) => handleUserContextMenu(e, message.authorUserId, message.authorDisplayName)}
                                            onContextMenu={(e) => handleUserContextMenu(e, message.authorUserId, message.authorDisplayName)}
                                        >
                                            {message.authorDisplayName}
                                        </strong>
                                        <time dateTime={message.createdAt}>{formatMessageTime(message.createdAt)}</time>
                                    </header>
                                ) : null}
                                <p>{message.content}</p>
                                {mediaUrls.length > 0 && (
                                    <div className="message-media-container">
                                        {mediaUrls.map((url, i) => (
                                            <div key={i} className="message-media">
                                                <img src={url} alt="Attached media" loading="lazy" />
                                            </div>
                                        ))}
                                    </div>
                                )}
                                {message.clientState === "sending" ? <small className="message-meta">Sending...</small> : null}
                                {message.clientState === "failed" ? (
                                    <small className="message-meta message-meta-error">
                                        Failed to send.
                                        <button
                                            type="button"
                                            className="inline-action"
                                            onClick={() => {
                                                void sendContentWithOptimistic(message.content, message.id);
                                            }}
                                        >
                                            Retry
                                        </button>
                                    </small>
                                ) : null}
                            </article>
                        </li>
                    );
                })}
            </ol>

            {contextMenu && (
                <ContextMenu
                    x={contextMenu.x}
                    y={contextMenu.y}
                    items={messageContextMenuItems}
                    onClose={() => setContextMenu(null)}
                />
            )}

            {userContextMenu && (
                <ContextMenu
                    x={userContextMenu.x}
                    y={userContextMenu.y}
                    items={userContextMenuItems}
                    onClose={() => setUserContextMenu(null)}
                />
            )}

            {!isNearBottom && pendingNewMessageCount > 0 ? (
                <div className="jump-latest">
                    <button type="button" onClick={jumpToLatest}>
                        Jump to latest ({pendingNewMessageCount})
                    </button>
                </div>
            ) : null}

            <form onSubmit={handleSendMessage} className="composer">
                <label htmlFor="message-input" className="sr-only">
                    Message
                </label>
                <div className="input-wrapper">
                    <textarea
                        id="message-input"
                        ref={messageInputRef}
                        value={draftMessage}
                        onChange={(event) => setDraftMessage(event.target.value)}
                        onPaste={handlePaste}
                        onKeyDown={(event) => {
                            if (event.key === "Enter" && !event.shiftKey) {
                                event.preventDefault();
                                if (draftMessage.trim()) {
                                    void submitDraftMessage();
                                }
                            }
                        }}
                        maxLength={2000}
                        placeholder={activeChannel ? `Message #${activeChannel.name}` : "Select a channel first"}
                        aria-label={activeChannel ? `Message #${activeChannel.name}` : "Message channel"}
                        disabled={!activeChannel || sending || isUploading}
                    />
                    {showEmojiPicker && (
                        <div className="emoji-picker-container">
                            <EmojiPicker
                                onEmojiClick={(emojiData: EmojiClickData) => {
                                    setDraftMessage(prev => prev + emojiData.emoji);
                                    setShowEmojiPicker(false);
                                }}
                                width={350}
                                height={400}
                                theme={theme as any}
                            />
                        </div>
                    )}
                    <div className="composer-trigger overlay">
                        <button
                            type="button"
                            className="composer-trigger"
                            title="Insert emoji"
                            onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                            disabled={!activeChannel || sending || isUploading}
                        >
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <circle cx="12" cy="12" r="10" />
                                <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                                <line x1="9" y1="9" x2="9.01" y2="9" />
                                <line x1="15" y1="9" x2="15.01" y2="9" />
                            </svg>
                        </button>
                        <button
                            type="button"
                            className="composer-trigger"
                            title="Attach image"
                            onClick={() => fileInputRef.current?.click()}
                            disabled={!activeChannel || isUploading}
                        >
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" />
                            </svg>
                        </button>
                    </div>
                    <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        ref={fileInputRef}
                        onChange={(e) => handleFileUpload(e.target.files)}
                    />
                </div>
                <div className="composer-actions">
                    <small className="char-count">{draftMessage.length}/2000</small>
                    <button type="submit" disabled={!activeChannel || sending || isUploading || (!draftMessage.trim() && !isUploading)}>
                        {sending ? "Sending..." : isUploading ? "Uploading..." : "Send"}
                    </button>
                </div>
            </form>
        </section>
    );
}
