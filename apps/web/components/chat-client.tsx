"use client";

import { FormEvent, KeyboardEvent as ReactKeyboardEvent, useCallback, useEffect, useMemo, useRef, useState } from "react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useChat, MessageItem, ModalType } from "../context/chat-context";
import { AuthOverlay } from "./auth-overlay";
import { Sidebar } from "./sidebar";
import { ChatWindow } from "./chat-window";
import Link from "next/link";
import { useToast } from "./toast-provider";
import type { Category, Channel, ChatMessage, MentionMarker, ModerationAction, ModerationReport, Server, VoicePresenceMember, VoiceTokenGrant } from "@escapehatch/shared";
import {
  bootstrapAdmin,
  createReport,
  connectMessageStream,
  completeUsernameOnboarding,
  createCategory,
  createChannel,
  createServer,
  deleteChannel,
  deleteCategory, // Added deleteCategory
  deleteServer,
  issueVoiceTokenWithVideo,
  fetchAllowedActions,
  fetchAuthProviders,
  fetchBootstrapStatus,
  fetchViewerSession,
  listHubs,
  listMentions,
  listAuditLogs,
  listReports,
  listChannelReadStates,
  listCategories,
  listChannels,
  listMessages,
  listServers,
  listViewerRoleBindings,
  joinVoicePresence,
  leaveVoicePresence,
  listVoicePresence,
  moveChannelCategory,
  performModerationAction,
  logout,
  providerLinkUrl,
  providerLoginUrl,
  renameCategory,
  renameChannel,
  renameServer,
  sendMessage,
  transitionReportStatus,
  updateChannelVideoControls,
  upsertChannelReadState,
  updateChannelControls,
  updateUserTheme,
  updateVoicePresenceState,
  controlPlaneBaseUrl,
  type AuthProvidersResponse,
  type BootstrapStatus,
  type ViewerRoleBinding,
  type PrivilegedAction,
  type ViewerSession
} from "../lib/control-plane";



function formatMessageTime(value: string): string {
  const date = new Date(value);
  return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

export function ChatClient() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const urlServerId = searchParams.get("server");
  const urlChannelId = searchParams.get("channel");
  const suggestedUsername = searchParams.get("suggestedUsername");

  const { state, dispatch } = useChat();
  const { showToast } = useToast();
  const {
    viewer,
    providers,
    bootstrapStatus,
    servers,
    channels,
    categories,
    messages,
    viewerRoles,
    selectedServerId,
    selectedChannelId,
    loading,
    error,
    realtimeState,
    allowedActions,
    theme,
    activeModal,
    isDetailsOpen,
    isAddMenuOpen,
    channelFilter,
    lastReadByChannel,
    mentionCountByChannel,
    isNearBottom,
    pendingNewMessageCount,
    lastSeenMessageId,
    renameSpaceId,
    renameSpaceName,
    renameCategoryId,
    renameCategoryName,
    renameRoomId,
    renameRoomName,
    renameRoomType,
    renameRoomCategoryId,
    selectedCategoryIdForCreate,
    voiceConnected,
    voiceMuted,
    voiceDeafened,
    voiceVideoEnabled,
    voiceVideoQuality,
    voiceGrant,
    voiceMembers,
    unreadCountByChannel,
    creatingSpace,
    creatingRoom,
    creatingCategory,
    mutatingStructure,
    deleteTargetSpaceId,
    deleteSpaceConfirm,
    deleteRoomConfirm,
    sending,
    updatingControls
  } = state;

  const [mentions, setMentions] = useState<MentionMarker[]>([]);

  const filteredChannels = useMemo(() => {
    const term = channelFilter.trim().toLowerCase();
    if (!term) return channels;
    return channels.filter((channel) => channel.name.toLowerCase().includes(term));
  }, [channels, channelFilter]);

  const groupedChannels = useMemo(() => {
    const byCategory = new Map<string | null, Channel[]>();
    for (const channel of filteredChannels) {
      const key = channel.categoryId ?? null;
      const bucket = byCategory.get(key) ?? [];
      bucket.push(channel);
      byCategory.set(key, bucket);
    }

    const groups: Array<{ id: string | null; name: string; channels: Channel[] }> = [];
    const uncategorized = byCategory.get(null) ?? [];
    if (uncategorized.length > 0) {
      groups.push({ id: null, name: "", channels: uncategorized });
    }

    for (const category of categories) {
      const channelsForCategory = byCategory.get(category.id) ?? [];
      groups.push({
        id: category.id,
        name: category.name,
        channels: channelsForCategory
      });
    }

    return groups;
  }, [categories, filteredChannels]);

  const groupedChannelIds = useMemo(() => {
    return filteredChannels.map(c => c.id);
  }, [filteredChannels]);

  const [draftMessage, setDraftMessage] = useState("");
  const [controlsOpen, setControlsOpen] = useState(false);
  const [controlsReason, setControlsReason] = useState("Channel policy update");
  const [slowModeSeconds, setSlowModeSeconds] = useState("0");

  const [spaceName, setSpaceName] = useState("New Space");
  const [roomName, setRoomName] = useState("new-room");
  const [roomType, setRoomType] = useState<"text" | "announcement" | "voice">("text");
  const [selectedHubIdForCreate, setSelectedHubIdForCreate] = useState<string | null>(null);
  const [categoryName, setCategoryName] = useState("New Category");

  const messagesRef = useRef<HTMLOListElement | null>(null);
  const messageInputRef = useRef<HTMLTextAreaElement | null>(null);
  const chatStateRequestIdRef = useRef(0);
  const initialChatLoadKeyRef = useRef<string | null>(null);

  useEffect(() => {
    const savedTheme = (viewer?.identity?.theme || localStorage.getItem("theme")) as "light" | "dark" | null;
    if (savedTheme) {
      dispatch({ type: "SET_THEME", payload: savedTheme });
    } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
      dispatch({ type: "SET_THEME", payload: "dark" });
    }
  }, [viewer?.identity, dispatch]);

  useEffect(() => {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("theme", theme);
  }, [theme]);

  const toggleTheme = useCallback(() => {
    const next = theme === "light" ? "dark" : "light";
    dispatch({ type: "SET_THEME", payload: next });
    void updateUserTheme(next);
  }, [theme, dispatch]);

  const canAccessWorkspace = Boolean(viewer && !viewer.needsOnboarding && bootstrapStatus?.initialized);
  const activeChannel = channels.find((channel) => channel.id === selectedChannelId) ?? null;
  const canManageChannel = useMemo(
    () =>
      allowedActions.includes("channel.lock") ||
      allowedActions.includes("channel.unlock") ||
      allowedActions.includes("channel.slowmode"),
    [allowedActions]
  );
  const canManageHub = useMemo(
    () => viewerRoles.some((binding) => binding.role === "hub_admin" && !binding.serverId),
    [viewerRoles]
  );
  const canManageCurrentSpace = useMemo(
    () =>
      viewerRoles.some(
        (binding) =>
          (binding.role === "hub_admin" || binding.role === "space_owner") &&
          (binding.serverId === selectedServerId || !binding.serverId)
      ),
    [viewerRoles, selectedServerId]
  );

  const memberRoster = useMemo(() => {
    const members = new Map<string, string>();
    for (const message of messages) {
      members.set(message.authorUserId, message.authorDisplayName);
    }
    return [...members.entries()].map(([id, displayName]) => ({ id, displayName }));
  }, [messages]);

  const renderedMessages = useMemo(() => {
    const grouped: Array<{
      message: MessageItem;
      showHeader: boolean;
      showDateDivider: boolean;
    }> = [];

    for (let index = 0; index < messages.length; index += 1) {
      const message = messages[index]!;
      const previous = messages[index - 1];
      const currentTime = new Date(message.createdAt).getTime();
      const previousTime = previous ? new Date(previous.createdAt).getTime() : null;
      const showHeader =
        !previous ||
        previous.authorUserId !== message.authorUserId ||
        previousTime === null ||
        currentTime - previousTime > 5 * 60 * 1000;

      const showDateDivider =
        !previous ||
        new Date(previous.createdAt).toDateString() !== new Date(message.createdAt).toDateString();

      grouped.push({
        message,
        showHeader,
        showDateDivider
      });
    }

    return grouped;
  }, [messages]);

  const setUrlSelection = useCallback(
    (serverId: string | null, channelId: string | null) => {
      const currentQuery = searchParams.toString();
      const next = new URLSearchParams(searchParams.toString());
      if (serverId) {
        next.set("server", serverId);
      } else {
        next.delete("server");
      }

      if (channelId) {
        next.set("channel", channelId);
      } else {
        next.delete("channel");
      }

      const query = next.toString();
      if (query === currentQuery) {
        return;
      }
      router.replace(query ? `${pathname}?${query}` : pathname, { scroll: false });
    },
    [pathname, router, searchParams]
  );

  const refreshAuthState = useCallback(async (): Promise<void> => {
    // We fetch critical auth meta individually to prevent total failure if one service (like DB) is lagging.
    try {
      const providerData = await fetchAuthProviders();
      dispatch({ type: "SET_PROVIDERS", payload: providerData });
    } catch (cause) {
      console.error("Failed to load auth providers:", cause);
      const message = cause instanceof Error ? cause.message : "Failed to load auth providers.";
      dispatch({ type: "SET_ERROR", payload: `${message} (Target: ${controlPlaneBaseUrl}/auth/providers)` });
    }

    const viewerData = await fetchViewerSession();
    dispatch({ type: "SET_VIEWER", payload: viewerData });

    try {
      const bootstrapData = await fetchBootstrapStatus();
      dispatch({ type: "SET_BOOTSTRAP_STATUS", payload: bootstrapData });
    } catch (cause) {
      console.error("Failed to load bootstrap status:", cause);
      // Keep previous status or null on failure.
    }

    void listViewerRoleBindings()
      .then((roleBindings) => dispatch({ type: "SET_VIEWER_ROLES", payload: roleBindings }))
      .catch(() => dispatch({ type: "SET_VIEWER_ROLES", payload: [] }));

    void listHubs()
      .then((items) => {
        dispatch({ type: "SET_HUBS", payload: items.map((h) => ({ id: h.id, name: h.name })) });
        if (items.length > 0 && items[0]) {
          setSelectedHubIdForCreate(items[0].id);
        }
      })
      .catch(() => dispatch({ type: "SET_HUBS", payload: [] }));
  }, [dispatch]);

  const refreshChatState = useCallback(async (preferredServerId?: string, preferredChannelId?: string): Promise<void> => {
    const requestId = ++chatStateRequestIdRef.current;
    const [serverItems, roleBindings] = await Promise.all([
      listServers(),
      listViewerRoleBindings()
    ]);
    if (requestId !== chatStateRequestIdRef.current) {
      return;
    }
    dispatch({ type: "SET_SERVERS", payload: serverItems });
    dispatch({ type: "SET_VIEWER_ROLES", payload: roleBindings });


    const candidateServerId =
      preferredServerId ??
      urlServerId ??
      selectedServerId ??
      serverItems[0]?.id ??
      null;
    const nextServerId =
      candidateServerId && serverItems.some((server) => server.id === candidateServerId)
        ? candidateServerId
        : (serverItems[0]?.id ?? null);
    dispatch({ type: "SET_SELECTED_SERVER_ID", payload: nextServerId });

    if (!nextServerId) {
      dispatch({ type: "SET_CHANNELS", payload: [] });
      dispatch({ type: "SET_CATEGORIES", payload: [] });
      dispatch({ type: "SET_SELECTED_CHANNEL_ID", payload: null });
      dispatch({ type: "SET_MESSAGES", payload: [] });
      setUrlSelection(null, null);
      return;
    }

    // Clear channels to show loading state or clear previous server's sidebar
    dispatch({ type: "SET_CHANNELS", payload: [] });
    dispatch({ type: "SET_CATEGORIES", payload: [] });

    const channelItems = await listChannels(nextServerId);
    if (requestId !== chatStateRequestIdRef.current) {
      return;
    }
    const categoryItems = await listCategories(nextServerId);
    if (requestId !== chatStateRequestIdRef.current) {
      return;
    }
    dispatch({ type: "SET_CHANNELS", payload: channelItems });
    dispatch({ type: "SET_CATEGORIES", payload: categoryItems });

    const textChannels = channelItems.filter((channel) => channel.type === "text" || channel.type === "announcement");

    let nextChannelId = selectedChannelId;
    let shouldFetchMessages = false;

    // If an explicit channel ID is provided via arguments or URL:
    if (preferredChannelId || urlChannelId) {
      const explicitId = preferredChannelId ?? urlChannelId;
      if (explicitId && channelItems.some((c) => c.id === explicitId)) {
        nextChannelId = explicitId;
        shouldFetchMessages = true;
      }
    }

    // If there is NO active channel selected yet:
    if (!nextChannelId) {
      nextChannelId = textChannels[0]?.id ?? channelItems[0]?.id ?? null;
      shouldFetchMessages = true;
    }

    if (nextChannelId !== selectedChannelId) {
      dispatch({ type: "SET_SELECTED_CHANNEL_ID", payload: nextChannelId });
    }

    if (nextChannelId && (shouldFetchMessages || !selectedChannelId)) {
      const nextChannelObj = channelItems.find(c => c.id === nextChannelId);
      if (nextChannelObj) {
        dispatch({ type: "SET_ACTIVE_CHANNEL_DATA", payload: nextChannelObj });
      }
    }

    setUrlSelection(nextServerId, nextChannelId);

    if (!nextChannelId) {
      dispatch({ type: "SET_MESSAGES", payload: [] });
      return;
    }

    if (shouldFetchMessages) {
      const messageItems = await listMessages(nextChannelId);
      if (requestId !== chatStateRequestIdRef.current) {
        return;
      }
      dispatch({ type: "SET_MESSAGES", payload: messageItems.map((message) => ({ ...message })) });
    }
  }, [selectedServerId, selectedChannelId, setUrlSelection, urlChannelId, urlServerId, dispatch]);

  const initialize = useCallback(async (): Promise<void> => {
    dispatch({ type: "SET_LOADING", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await refreshAuthState();
    } catch (cause) {
      const msg = cause instanceof Error ? cause.message : "Failed to load auth state.";
      dispatch({ type: "SET_ERROR", payload: msg });
      showToast(msg, "error");
    } finally {
      dispatch({ type: "SET_LOADING", payload: false });
    }
  }, [refreshAuthState, dispatch]);

  useEffect(() => {
    void initialize();
  }, [initialize]);

  // Potential bug trigger: This effect initializes the chat state (server/channel) based on 
  // bootstrap defaults. If bootstrapStatus or its properties update unexpectedly, this 
  // could reset the user's manual space selection back to the default space.
  useEffect(() => {
    if (!viewer || viewer.needsOnboarding || !bootstrapStatus?.initialized) {
      initialChatLoadKeyRef.current = null;
      return;
    }

    const loadKey = [
      viewer.productUserId,
      bootstrapStatus.defaultServerId ?? "",
      bootstrapStatus.defaultChannelId ?? ""
    ].join(":");
    if (initialChatLoadKeyRef.current === loadKey) {
      return;
    }
    initialChatLoadKeyRef.current = loadKey;

    void refreshChatState(bootstrapStatus.defaultServerId ?? undefined, bootstrapStatus.defaultChannelId ?? undefined).catch(
      (cause) => {
        const msg = cause instanceof Error ? cause.message : "Failed to load chat state.";
        dispatch({ type: "SET_ERROR", payload: msg });
        showToast(msg, "error");
      }
    );
  }, [viewer, bootstrapStatus?.initialized, bootstrapStatus?.defaultServerId, bootstrapStatus?.defaultChannelId, refreshChatState]);

  useEffect(() => {
    if (!canAccessWorkspace || !selectedServerId) {
      dispatch({ type: "SET_ALLOWED_ACTIONS", payload: [] });
      return;
    }

    void fetchAllowedActions(selectedServerId, selectedChannelId ?? undefined)
      .then((actions) => dispatch({ type: "SET_ALLOWED_ACTIONS", payload: actions }))
      .catch(() => {
        dispatch({ type: "SET_ALLOWED_ACTIONS", payload: [] });
      });
  }, [canAccessWorkspace, selectedServerId, selectedChannelId, dispatch]);

  useEffect(() => {
    if (!canAccessWorkspace || !selectedServerId) {
      // Need a way to clear all read states or just ignore
      return;
    }

    void listChannelReadStates(selectedServerId)
      .then((items) => {
        for (const item of items) {
          dispatch({ type: "SET_LAST_READ", payload: { channelId: item.channelId, lastSeenId: item.lastReadAt } });
        }
      })
      .catch(() => {
        // Keep local map if read-state fetch fails.
      });
  }, [canAccessWorkspace, selectedServerId, dispatch]);


  useEffect(() => {
    if (!canAccessWorkspace || !selectedChannelId) {
      dispatch({ type: "SET_MENTION_COUNTS", payload: {} });
      return;
    }

    void listMentions(selectedChannelId, 150)
      .then((items) => {
        dispatch({ type: "SET_MENTION_COUNTS", payload: { [selectedChannelId]: items.length } });
      })
      .catch(() => {
        // Keep previous mention snapshot on fetch failures.
      });
  }, [canAccessWorkspace, selectedChannelId, dispatch]);

  useEffect(() => {
    dispatch({ type: "SET_PENDING_NEW_MESSAGE_COUNT", payload: 0 });
    dispatch({ type: "SET_LAST_SEEN_MESSAGE_ID", payload: null });
    dispatch({ type: "SET_NEAR_BOTTOM", payload: true });
    dispatch({ type: "SET_VOICE_CONNECTED", payload: false });
    dispatch({ type: "SET_VOICE_MUTED", payload: false });
    dispatch({ type: "SET_VOICE_DEAFENED", payload: false });
    dispatch({ type: "SET_VOICE_GRANT", payload: null });
    dispatch({ type: "SET_VOICE_MEMBERS", payload: [] });
  }, [selectedChannelId, dispatch]);

  useEffect(() => {
    const selectedServer = servers.find((server) => server.id === selectedServerId);
    dispatch({ type: "SET_RENAME_SPACE", payload: { id: selectedServer?.id ?? "", name: selectedServer?.name ?? "" } });
    dispatch({ type: "SET_DELETE_TARGET_SPACE_ID", payload: state.deleteTargetSpaceId || selectedServer?.id || servers[0]?.id || "" });
  }, [selectedServerId, servers, dispatch]);

  useEffect(() => {
    const selected = channels.find((channel) => channel.id === selectedChannelId);
    dispatch({ type: "SET_RENAME_ROOM", payload: { id: selected?.id ?? "", name: selected?.name ?? "", type: selected?.type ?? "text", categoryId: selected?.categoryId ?? null } });
    dispatch({ type: "SET_SELECTED_CATEGORY_FOR_CREATE", payload: selected?.categoryId ?? "" });
  }, [channels, selectedChannelId, dispatch]);

  useEffect(() => {
    if (categories.length === 0) {
      dispatch({ type: "SET_RENAME_CATEGORY", payload: { id: "", name: "" } });
      dispatch({ type: "SET_SELECTED_CATEGORY_FOR_CREATE", payload: "" });
      return;
    }

    const current = categories.find((category) => category.id === renameCategoryId);
    const selected = current ?? categories[0]!;
    dispatch({ type: "SET_RENAME_CATEGORY", payload: { id: selected.id, name: selected.name } });
    dispatch({ type: "SET_SELECTED_CATEGORY_FOR_CREATE", payload: selected.id });
  }, [categories, renameCategoryId, dispatch]);

  useEffect(() => {
    if (!selectedChannelId) {
      return;
    }

    const newest = messages[messages.length - 1];
    if (!newest) {
      return;
    }

    dispatch({ type: "SET_LAST_READ", payload: { channelId: selectedChannelId, lastSeenId: newest.createdAt } });

    void upsertChannelReadState(selectedChannelId, newest.createdAt).catch(() => {
      // Ignore transient read-state sync errors.
    });
  }, [messages, selectedChannelId]);

  useEffect(() => {
    if (!voiceConnected || !selectedServerId || !selectedChannelId || activeChannel?.type !== "voice") {
      dispatch({ type: "SET_VOICE_MEMBERS", payload: [] });
      return;
    }

    let stopped = false;
    const refresh = () => {
      void listVoicePresence({
        serverId: selectedServerId,
        channelId: selectedChannelId
      })
        .then((items) => {
          if (stopped) {
            return;
          }
          dispatch({ type: "SET_VOICE_MEMBERS", payload: items });
        })
        .catch(() => {
          // Keep previous roster on transient failures.
        });
    };

    refresh();
    const timer = setInterval(refresh, 3000);
    return () => {
      stopped = true;
      clearInterval(timer);
    };
  }, [voiceConnected, selectedServerId, selectedChannelId, activeChannel?.type]);

  useEffect(() => {
    const newest = messages[messages.length - 1];
    if (!newest || newest.id === lastSeenMessageId) {
      return;
    }

    const list = messagesRef.current;
    if (!list) {
      return;
    }

    if (isNearBottom) {
      list.scrollTop = list.scrollHeight;
      dispatch({ type: "SET_PENDING_NEW_MESSAGE_COUNT", payload: 0 });
      dispatch({ type: "SET_LAST_SEEN_MESSAGE_ID", payload: newest.id });
      return;
    }

    dispatch({ type: "SET_PENDING_NEW_MESSAGE_COUNT", payload: pendingNewMessageCount + 1 });
    dispatch({ type: "SET_LAST_SEEN_MESSAGE_ID", payload: newest.id });
  }, [isNearBottom, lastSeenMessageId, messages]);

  useEffect(() => {
    if (!canAccessWorkspace || !selectedChannelId) {
      dispatch({ type: "SET_REALTIME_STATE", payload: "disconnected" });
      return;
    }

    let closed = false;
    let pollInterval: ReturnType<typeof setInterval> | null = null;

    const startPolling = () => {
      if (pollInterval) {
        return;
      }

      dispatch({ type: "SET_REALTIME_STATE", payload: "polling" });
      pollInterval = setInterval(() => {
        void listMessages(selectedChannelId)
          .then((next) => dispatch({ type: "SET_MESSAGES", payload: next.map((message) => ({ ...message })) }))
          .catch(() => {
            // Keep previous messages on transient polling failures.
          });
      }, 3000);
    };

    const stopPolling = () => {
      if (!pollInterval) {
        return;
      }
      clearInterval(pollInterval);
      pollInterval = null;
    };

    startPolling();

    const disconnectStream = connectMessageStream(selectedChannelId, {
      onOpen: () => {
        if (closed) {
          return;
        }
        stopPolling();
        dispatch({ type: "SET_REALTIME_STATE", payload: "live" });
      },
      onError: () => {
        if (closed) {
          return;
        }
        startPolling();
      },
      onMessageCreated: (message) => {
        dispatch({
          type: "UPDATE_MESSAGES",
          payload: (current) => {
            if (current.some((item) => item.id === message.id)) {
              return current;
            }
            return [...current, message];
          }
        });
      }
    });

    return () => {
      closed = true;
      disconnectStream();
      stopPolling();
    };
  }, [canAccessWorkspace, selectedChannelId]);


  function getAdjacentId(currentId: string, ids: string[], direction: "next" | "previous"): string | null {
    if (ids.length === 0) {
      return null;
    }
    const currentIndex = ids.indexOf(currentId);
    if (currentIndex === -1) {
      return ids[0] ?? null;
    }

    const offset = direction === "next" ? 1 : -1;
    const nextIndex = (currentIndex + offset + ids.length) % ids.length;
    return ids[nextIndex] ?? null;
  }

  function handleServerKeyboardNavigation(event: ReactKeyboardEvent, currentServerId: string): void {
    const serverIds = servers.map((server) => server.id);
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextId = getAdjacentId(currentServerId, serverIds, "next");
      if (nextId) {
        void handleServerChange(nextId);
      }
      return;
    }

    if (event.key === "ArrowUp") {
      event.preventDefault();
      const previousId = getAdjacentId(currentServerId, serverIds, "previous");
      if (previousId) {
        void handleServerChange(previousId);
      }
      return;
    }

    if (event.key === "Home") {
      event.preventDefault();
      const first = serverIds[0];
      if (first) {
        void handleServerChange(first);
      }
      return;
    }

    if (event.key === "End") {
      event.preventDefault();
      const last = serverIds[serverIds.length - 1];
      if (last) {
        void handleServerChange(last);
      }
    }
  }

  function handleChannelKeyboardNavigation(event: ReactKeyboardEvent, currentChannelId: string): void {
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextId = getAdjacentId(currentChannelId, groupedChannelIds, "next");
      if (nextId) {
        void handleChannelChange(nextId);
      }
      return;
    }

    if (event.key === "ArrowUp") {
      event.preventDefault();
      const previousId = getAdjacentId(currentChannelId, groupedChannelIds, "previous");
      if (previousId) {
        void handleChannelChange(previousId);
      }
      return;
    }

    if (event.key === "Home") {
      event.preventDefault();
      const first = groupedChannelIds[0];
      if (first) {
        void handleChannelChange(first);
      }
      return;
    }

    if (event.key === "End") {
      event.preventDefault();
      const last = groupedChannelIds[groupedChannelIds.length - 1];
      if (last) {
        void handleChannelChange(last);
      }
    }
  }

  async function handleServerChange(serverId: string): Promise<void> {
    dispatch({ type: "SET_SELECTED_SERVER_ID", payload: serverId });
    dispatch({ type: "SET_CHANNELS", payload: [] });
    dispatch({ type: "SET_CATEGORIES", payload: [] });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await refreshChatState(serverId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to load channels." });
    }
  }

  async function handleChannelChange(channelId: string): Promise<void> {
    const channel = channels.find(c => c.id === channelId);
    if (channel) {
      dispatch({ type: "SET_ACTIVE_CHANNEL_DATA", payload: channel });
    }
    dispatch({ type: "SET_SELECTED_CHANNEL_ID", payload: channelId });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      const next = await listMessages(channelId);
      dispatch({ type: "SET_MESSAGES", payload: next.map((message) => ({ ...message })) });
      setUrlSelection(selectedServerId, channelId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to load messages." });
    }
  }

  function handleMessageListScroll(event?: React.UIEvent<HTMLOListElement>): void {
    const list = messagesRef.current;
    if (!list) {
      return;
    }

    const distanceFromBottom = list.scrollHeight - list.scrollTop - list.clientHeight;
    const nearBottom = distanceFromBottom < 24;
    dispatch({ type: "SET_NEAR_BOTTOM", payload: nearBottom });
    if (nearBottom) {
      dispatch({ type: "SET_PENDING_NEW_MESSAGE_COUNT", payload: 0 });
    }
  }

  function jumpToLatest(): void {
    const list = messagesRef.current;
    if (!list) {
      return;
    }

    list.scrollTop = list.scrollHeight;
    dispatch({ type: "SET_NEAR_BOTTOM", payload: true });
    dispatch({ type: "SET_PENDING_NEW_MESSAGE_COUNT", payload: 0 });
  }

  async function handleSetLock(lock: boolean): Promise<void> {
    if (!activeChannel || !selectedServerId) {
      return;
    }

    dispatch({ type: "SET_UPDATING_CONTROLS", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await updateChannelControls({
        channelId: activeChannel.id,
        serverId: selectedServerId,
        lock,
        reason: controlsReason
      });
      await refreshChatState(selectedServerId, activeChannel.id);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update lock state." });
    } finally {
      dispatch({ type: "SET_UPDATING_CONTROLS", payload: false });
    }
  }

  async function handleCreateSpace(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedHubIdForCreate || !spaceName.trim()) {
      return;
    }

    dispatch({ type: "SET_CREATING_SPACE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      const created = await createServer({
        hubId: selectedHubIdForCreate,
        name: spaceName.trim()
      });
      setSpaceName("New Space");
      await refreshChatState(created.id);
      setUrlSelection(created.id, null);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to create space." });
    } finally {
      dispatch({ type: "SET_CREATING_SPACE", payload: false });
    }
  }

  async function handleCreateRoom(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedServerId || !roomName.trim()) {
      return;
    }

    dispatch({ type: "SET_CREATING_ROOM", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      const created = await createChannel({
        serverId: selectedServerId,
        name: roomName.trim(),
        type: roomType,
        categoryId: selectedCategoryIdForCreate || undefined
      });
      setRoomName("new-room");
      await refreshChatState(selectedServerId, created.id);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to create room." });
    } finally {
      dispatch({ type: "SET_CREATING_ROOM", payload: false });
    }
  }

  async function handleCreateCategory(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedServerId || !categoryName.trim()) {
      return;
    }

    dispatch({ type: "SET_CREATING_CATEGORY", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await createCategory({
        serverId: selectedServerId,
        name: categoryName.trim()
      });
      setCategoryName("New Category");
      await refreshChatState(selectedServerId, selectedChannelId ?? undefined);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to create category." });
    } finally {
      dispatch({ type: "SET_CREATING_CATEGORY", payload: false });
    }
  }

  async function handleRenameCategory(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedServerId || !renameCategoryId || !renameCategoryName.trim()) {
      return;
    }

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await renameCategory({
        categoryId: renameCategoryId,
        serverId: selectedServerId,
        name: renameCategoryName.trim()
      });
      await refreshChatState(selectedServerId, selectedChannelId ?? undefined);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to rename category." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function moveCategoryPosition(categoryId: string, direction: "up" | "down"): Promise<void> {
    if (!selectedServerId) return;
    const index = categories.findIndex(c => c.id === categoryId);
    if (index === -1) return;

    const targetIndex = direction === "up" ? index - 1 : index + 1;
    const neighbor = categories[targetIndex];
    if (!neighbor) return;

    const current = categories[index];
    if (!current) return;

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    try {
      // Swap positions
      await Promise.all([
        renameCategory({ categoryId: current.id, serverId: selectedServerId, position: neighbor.position }),
        renameCategory({ categoryId: neighbor.id, serverId: selectedServerId, position: current.position })
      ]);
      await refreshChatState(selectedServerId, selectedChannelId ?? undefined);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to reorder category." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleMoveSelectedRoomCategory(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    if (!selectedServerId || !selectedChannelId) {
      return;
    }

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await moveChannelCategory({
        channelId: selectedChannelId,
        serverId: selectedServerId,
        categoryId: selectedCategoryIdForCreate || null
      });
      await refreshChatState(selectedServerId, selectedChannelId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to move room." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleDeleteCategory(categoryId: string): Promise<void> {
    if (!selectedServerId) {
      return;
    }

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await deleteCategory({
        serverId: selectedServerId,
        categoryId: categoryId
      });
      await refreshChatState(selectedServerId, selectedChannelId ?? undefined);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to delete category." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleRenameSpace(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    if (!renameSpaceId || !renameSpaceName.trim()) {
      return;
    }

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await renameServer({
        serverId: renameSpaceId,
        name: renameSpaceName.trim()
      });
      dispatch({ type: "SET_RENAME_SPACE", payload: { id: renameSpaceId, name: "" } });
      await refreshChatState(renameSpaceId, selectedChannelId ?? undefined);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to rename space." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleDeleteSpace(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    const targetServerId = state.deleteTargetSpaceId || renameSpaceId || selectedServerId;
    if (!targetServerId) return;
    if (state.deleteSpaceConfirm.trim() !== "DELETE SPACE") {
      dispatch({ type: "SET_ERROR", payload: "Type DELETE SPACE to confirm." });
      return;
    }
    await performDeleteSpace(targetServerId);
  }

  async function performDeleteSpace(serverId: string): Promise<void> {
    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await deleteServer(serverId);
      dispatch({ type: "SET_DELETE_SPACE_CONFIRM", payload: "" });
      const remainingServers = servers.filter((s) => s.id !== serverId);
      await refreshChatState(remainingServers[0]?.id);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to delete space." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleRenameRoom(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!renameRoomId || !renameRoomName.trim() || !selectedServerId) {
      return;
    }

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await renameChannel({
        channelId: renameRoomId,
        serverId: selectedServerId,
        name: renameRoomName.trim(),
        type: renameRoomType,
        categoryId: renameRoomCategoryId
      });
      dispatch({ type: "SET_RENAME_ROOM", payload: { id: renameRoomId, name: "", type: renameRoomType, categoryId: renameRoomCategoryId } });
      await refreshChatState(selectedServerId, renameRoomId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update room." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function moveChannelPosition(channelId: string, direction: "up" | "down"): Promise<void> {
    if (!selectedServerId) return;
    const channel = channels.find(c => c.id === channelId);
    if (!channel) return;

    // Reordering happens WITHIN the same category (or within Uncategorized)
    const peers = channels
      .filter(c => c.categoryId === channel.categoryId)
      .sort((a, b) => a.position - b.position || a.createdAt.localeCompare(b.createdAt));

    const index = peers.findIndex(c => c.id === channelId);
    const targetIndex = direction === "up" ? index - 1 : index + 1;
    const neighbor = peers[targetIndex];
    if (!neighbor) return;

    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    try {
      await Promise.all([
        renameChannel({ channelId: channel.id, serverId: selectedServerId, position: neighbor.position }),
        renameChannel({ channelId: neighbor.id, serverId: selectedServerId, position: channel.position })
      ]);
      await refreshChatState(selectedServerId, channelId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to reorder room." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleDeleteRoom(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedChannelId || !selectedServerId) return;
    if (state.deleteRoomConfirm.trim() !== "DELETE ROOM") {
      dispatch({ type: "SET_ERROR", payload: "Type DELETE ROOM to confirm." });
      return;
    }
    await performDeleteRoom(selectedServerId, selectedChannelId);
  }

  async function performDeleteRoom(serverId: string, channelId: string): Promise<void> {
    dispatch({ type: "SET_MUTATING_STRUCTURE", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await deleteChannel({ serverId, channelId });
      dispatch({ type: "SET_DELETE_ROOM_CONFIRM", payload: "" });
      const remainingChannels = channels.filter((c) => c.id !== channelId);
      await refreshChatState(serverId, remainingChannels[0]?.id);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to delete room." });
    } finally {
      dispatch({ type: "SET_MUTATING_STRUCTURE", payload: false });
    }
  }

  async function handleUpdateSlowMode(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    if (!activeChannel || !selectedServerId) {
      return;
    }

    const parsed = Number(slowModeSeconds);
    if (!Number.isFinite(parsed) || parsed < 0 || parsed > 600) {
      dispatch({ type: "SET_ERROR", payload: "Slow mode must be between 0 and 600 seconds." });
      return;
    }

    dispatch({ type: "SET_UPDATING_CONTROLS", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await updateChannelControls({
        channelId: activeChannel.id,
        serverId: selectedServerId,
        slowModeSeconds: Math.floor(parsed),
        reason: controlsReason
      });
      await refreshChatState(selectedServerId, activeChannel.id);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update slow mode." });
    } finally {
      dispatch({ type: "SET_UPDATING_CONTROLS", payload: false });
    }
  }


  async function handleJoinVoice(): Promise<void> {
    if (!selectedServerId || !selectedChannelId || activeChannel?.type !== "voice") {
      return;
    }

    dispatch({ type: "SET_ERROR", payload: null });
    try {
      const grant = await issueVoiceTokenWithVideo({
        serverId: selectedServerId,
        channelId: selectedChannelId,
        videoQuality: voiceVideoQuality
      });
      await joinVoicePresence({
        serverId: selectedServerId,
        channelId: selectedChannelId,
        muted: voiceMuted,
        deafened: voiceDeafened,
        videoEnabled: voiceVideoEnabled,
        videoQuality: voiceVideoQuality
      });
      dispatch({ type: "SET_VOICE_GRANT", payload: grant });
      dispatch({ type: "SET_VOICE_CONNECTED", payload: true });
      dispatch({
        type: "SET_VOICE_MEMBERS",
        payload: await listVoicePresence({
          serverId: selectedServerId,
          channelId: selectedChannelId
        })
      });
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to join voice." });
    }
  }

  async function handleLeaveVoice(): Promise<void> {
    if (!selectedServerId || !selectedChannelId || !voiceConnected) {
      return;
    }

    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await leaveVoicePresence({
        serverId: selectedServerId,
        channelId: selectedChannelId
      });
      dispatch({ type: "SET_VOICE_CONNECTED", payload: false });
      dispatch({ type: "SET_VOICE_GRANT", payload: null });
      dispatch({ type: "SET_VOICE_MEMBERS", payload: [] });
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to leave voice." });
    }
  }

  async function handleToggleMuteDeafen(nextMuted: boolean, nextDeafened: boolean): Promise<void> {
    if (!selectedServerId || !selectedChannelId || !voiceConnected) {
      dispatch({ type: "SET_VOICE_MUTED", payload: nextMuted });
      dispatch({ type: "SET_VOICE_DEAFENED", payload: nextDeafened });
      return;
    }

    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await updateVoicePresenceState({
        serverId: selectedServerId,
        channelId: selectedChannelId,
        muted: nextMuted,
        deafened: nextDeafened,
        videoEnabled: voiceVideoEnabled,
        videoQuality: voiceVideoQuality
      });
      dispatch({ type: "SET_VOICE_MUTED", payload: nextMuted });
      dispatch({ type: "SET_VOICE_DEAFENED", payload: nextDeafened });
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update voice state." });
    }
  }

  async function handleToggleVideo(nextVideoEnabled: boolean): Promise<void> {
    dispatch({ type: "SET_VOICE_VIDEO_ENABLED", payload: nextVideoEnabled });
    if (!selectedServerId || !selectedChannelId || !voiceConnected) {
      return;
    }
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await updateVoicePresenceState({
        serverId: selectedServerId,
        channelId: selectedChannelId,
        muted: voiceMuted,
        deafened: voiceDeafened,
        videoEnabled: nextVideoEnabled,
        videoQuality: voiceVideoQuality
      });
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update video state." });
    }
  }

  async function handleSetVoiceChannelVideoDefaults(event: FormEvent<HTMLFormElement>): Promise<void> {
    event.preventDefault();
    if (!selectedServerId || !selectedChannelId || activeChannel?.type !== "voice") {
      return;
    }
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await updateChannelVideoControls({
        channelId: selectedChannelId,
        serverId: selectedServerId,
        videoEnabled: voiceVideoEnabled,
        maxVideoParticipants: 4
      });
      await refreshChatState(selectedServerId, selectedChannelId);
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Failed to update voice defaults." });
    }
  }


  async function sendContentWithOptimistic(content: string, existingMessageId?: string): Promise<void> {
    if (!selectedChannelId || !viewer || !content.trim()) {
      return;
    }

    const tempId = existingMessageId ?? `tmp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const optimisticMessage: MessageItem = {
      id: tempId,
      channelId: selectedChannelId,
      authorUserId: viewer.productUserId,
      authorDisplayName: viewer.identity?.preferredUsername ?? "You",
      content,
      createdAt: new Date().toISOString(),
      clientState: "sending"
    };

    dispatch({
      type: "SET_MESSAGES",
      payload: messages.some((item) => item.id === existingMessageId)
        ? messages.map((item) => (item.id === existingMessageId ? optimisticMessage : item))
        : [...messages, optimisticMessage]
    });

    dispatch({ type: "SET_SENDING", payload: true });
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      const persisted = await sendMessage(selectedChannelId, content.trim());
      dispatch({
        type: "SET_MESSAGES",
        payload: state.messages.map((item) => (item.id === tempId ? persisted : item))
      });
    } catch (cause) {
      dispatch({
        type: "SET_MESSAGES",
        payload: state.messages.map((item) =>
          item.id === tempId
            ? {
              ...item,
              clientState: "failed"
            }
            : item
        )
      });
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Message send failed." });
    } finally {
      dispatch({ type: "SET_SENDING", payload: false });
    }
  }

  async function submitDraftMessage(): Promise<void> {
    if (!selectedChannelId || !draftMessage.trim()) {
      return;
    }

    const content = draftMessage.trim();
    setDraftMessage("");
    await sendContentWithOptimistic(content);
    messageInputRef.current?.focus();
  }

  async function handleSendMessage(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    await submitDraftMessage();
  }

  async function handleLogout(): Promise<void> {
    dispatch({ type: "SET_ERROR", payload: null });
    try {
      await logout();
      dispatch({ type: "SET_VIEWER", payload: null });
      dispatch({ type: "SET_SERVERS", payload: [] });
      dispatch({ type: "SET_CHANNELS", payload: [] });
      dispatch({ type: "SET_MESSAGES", payload: [] });
      await initialize();
    } catch (cause) {
      dispatch({ type: "SET_ERROR", payload: cause instanceof Error ? cause.message : "Logout failed." });
    }
  }

  if (loading) {
    return (
      <main className="app">
        <section className="panel">
          <h1>EscapeHatch</h1>
          <p>Loading local workspace...</p>
        </section>
      </main>
    );
  }

  return (
    <main className="app">
      <header className="topbar">
        <h1>EscapeHatch Local Chat</h1>
        <div className="topbar-meta">
          <button
            type="button"
            className="icon-button"
            title={theme === "light" ? "Switch to Dark Mode" : "Switch to Light Mode"}
            aria-label={theme === "light" ? "Switch to Dark Mode" : "Switch to Light Mode"}
            onClick={toggleTheme}
          >
            {theme === "light" ? "üåô" : "‚òÄÔ∏è"}
          </button>
          {canManageCurrentSpace ? (
            <Link href="/admin" className="ghost">
              Admin Console
            </Link>
          ) : null}
          <Link href="/settings" className="icon-button" title="User Settings" aria-label="User Settings">
            ‚öôÔ∏è
          </Link>
          <span className="status-pill" data-state={realtimeState}>
            {realtimeState === "live" ? "Live" : realtimeState === "polling" ? "Polling" : "Offline"}
          </span>
          <span aria-live="polite">
            Signed in as {viewer?.identity?.preferredUsername ?? "Guest"}
          </span>
          {viewer ? (
            <button type="button" className="ghost" onClick={handleLogout}>
              Sign out
            </button>
          ) : null}
        </div>
      </header>

      {error && <p className="error" role="alert">{error}</p>}

      <AuthOverlay />

      <div
        className={`sidebar-overlay ${state.isSidebarOpen ? "visible" : ""}`}
        onClick={() => dispatch({ type: "SET_SIDEBAR_OPEN", payload: false })}
      />

      <div
        className={`details-overlay ${isDetailsOpen ? "visible" : ""}`}
        onClick={() => dispatch({ type: "SET_DETAILS_OPEN", payload: false })}
      />

      {canAccessWorkspace && (
        <section
          className={`chat-shell ${isDetailsOpen ? "" : "details-collapsed"} ${state.isSidebarOpen ? "sidebar-open" : ""}`}
          aria-label="Chat workspace"
        >
          <div className="sidebar-drawer-container">
            <Sidebar
              handleServerChange={handleServerChange}
              handleChannelChange={handleChannelChange}
              handleServerKeyboardNavigation={handleServerKeyboardNavigation}
              handleChannelKeyboardNavigation={handleChannelKeyboardNavigation}
              performDeleteSpace={performDeleteSpace}
              performDeleteRoom={performDeleteRoom}
            />
          </div>
          <ChatWindow
            handleSendMessage={handleSendMessage}
            handleUpdateSlowMode={handleUpdateSlowMode}
            handleSetLock={handleSetLock}
            handleMessageListScroll={handleMessageListScroll}
            jumpToLatest={jumpToLatest}
            submitDraftMessage={submitDraftMessage}
            sendContentWithOptimistic={sendContentWithOptimistic}
            handleJoinVoice={handleJoinVoice}
            handleLeaveVoice={handleLeaveVoice}
            toggleTheme={toggleTheme}
            handleLogout={handleLogout}
            draftMessage={draftMessage}
            setDraftMessage={setDraftMessage}
            controlsOpen={controlsOpen}
            setControlsOpen={setControlsOpen}
            slowModeSeconds={slowModeSeconds}
            setSlowModeSeconds={setSlowModeSeconds}
            controlsReason={controlsReason}
            setControlsReason={setControlsReason}
            updatingControls={updatingControls}
            sending={sending}
            voiceConnected={voiceConnected}
            voiceGrant={voiceGrant}
            mentions={mentions}
          />

          <div className="details-drawer-container">
            {isDetailsOpen && (
              <aside className="context panel" aria-label="Channel context">
                <h2>Channel Details</h2>
                {activeChannel ? (
                  <>
                    <p className="context-line">
                      <strong>Name:</strong> #{activeChannel.name}
                    </p>
                    <p className="context-line">
                      <strong>Type:</strong> {activeChannel.type}
                    </p>
                    <p className="context-line">
                      <strong>Locked:</strong> {activeChannel.isLocked ? "Yes" : "No"}
                    </p>
                    <p className="context-line">
                      <strong>Slow mode:</strong> {activeChannel.slowModeSeconds}s
                    </p>
                    {(mentions.length ?? 0) > 0 ? (
                      <p className="context-line">
                        <strong>Mentions in channel:</strong> {mentions.length}
                      </p>
                    ) : null}
                    {activeChannel.type === "voice" ? (
                      <>
                        <hr />
                        <h3>Voice Controls</h3>
                        <p className="context-line">
                          <strong>Status:</strong> {voiceConnected ? "Connected" : "Disconnected"}
                        </p>
                        {voiceGrant ? (
                          <p className="context-line">
                            <strong>Voice Room:</strong> {voiceGrant.sfuRoomId}
                          </p>
                        ) : null}
                        <div className="voice-actions">
                          {!voiceConnected ? (
                            <button
                              type="button"
                              onClick={() => {
                                void handleJoinVoice();
                              }}
                            >
                              Join Voice
                            </button>
                          ) : (
                            <button
                              type="button"
                              className="ghost"
                              onClick={() => {
                                void handleLeaveVoice();
                              }}
                            >
                              Leave Voice
                            </button>
                          )}
                        </div>
                      </>
                    ) : null}
                  </>
                ) : (
                  <p>Select a channel to see details</p>
                )}
              </aside>
            )}
          </div>
        </section>
      )}

      {activeModal && (
        <div className="modal-backdrop" onClick={() => dispatch({ type: "SET_ACTIVE_MODAL", payload: null })}>
          <div className="modal-panel" onClick={(e) => e.stopPropagation()}>
            <header className="modal-header">
              <h2>
                {activeModal === "create-space" && "Create New Space"}
                {activeModal === "create-category" && "Create New Category"}
                {activeModal === "create-room" && "Create New Room"}
                {activeModal === "rename-space" && "Rename Space"}
                {activeModal === "rename-category" && "Rename Category"}
                {activeModal === "rename-room" && "Rename Room"}
              </h2>
              <button type="button" className="ghost" onClick={() => dispatch({ type: "SET_ACTIVE_MODAL", payload: null })}>√ó</button>
            </header>

            {activeModal === "create-space" && (
              <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                void handleCreateSpace(event);
                dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
              }}>
                <label htmlFor="space-name-modal">Space Name</label>
                <input
                  id="space-name-modal"
                  autoFocus
                  value={spaceName}
                  onChange={(e) => setSpaceName(e.target.value)}
                  minLength={2}
                  maxLength={80}
                  required
                />
                <button type="submit" disabled={creatingSpace}>Create Space</button>
              </form>
            )}

            {activeModal === "rename-space" && (
              <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                void handleRenameSpace(event);
                dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
              }}>
                <label htmlFor="rename-space-modal">New Space Name</label>
                <input
                  id="rename-space-modal"
                  autoFocus
                  value={renameSpaceName}
                  onChange={(e) => dispatch({ type: "SET_RENAME_SPACE", payload: { id: renameSpaceId, name: e.target.value } })}
                  minLength={2}
                  maxLength={80}
                  required
                />
                <button type="submit" disabled={mutatingStructure}>Save Changes</button>
              </form>
            )}

            {activeModal === "create-category" && (
              <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                void handleCreateCategory(event);
                dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
              }}>
                <label htmlFor="category-name-modal">Category Name</label>
                <input
                  id="category-name-modal"
                  autoFocus
                  value={categoryName}
                  onChange={(e) => setCategoryName(e.target.value)}
                  minLength={2}
                  maxLength={80}
                  required
                />
                <button type="submit" disabled={creatingCategory}>Create Category</button>
              </form>
            )}

            {activeModal === "rename-category" && (
              <div className="stack">
                <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                  void handleRenameCategory(event);
                  dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
                }}>
                  <p>Editing category: <strong>{categories.find(c => c.id === renameCategoryId)?.name}</strong></p>
                  <label htmlFor="rename-category-modal">Category Name</label>
                  <input
                    id="rename-category-modal"
                    autoFocus
                    value={renameCategoryName}
                    onChange={(e) => dispatch({ type: "SET_RENAME_CATEGORY", payload: { id: renameCategoryId, name: e.target.value } })}
                    minLength={2}
                    maxLength={80}
                    required
                  />
                  <button type="submit" disabled={mutatingStructure}>Save Name</button>
                </form>

                <div className="stack" style={{ borderTop: "1px solid var(--border)", paddingTop: "1rem" }}>
                  <p>Reorder Category</p>
                  <div style={{ display: "flex", gap: "0.5rem" }}>
                    <button
                      type="button"
                      disabled={mutatingStructure || categories.findIndex(c => c.id === renameCategoryId) === 0}
                      onClick={() => moveCategoryPosition(renameCategoryId, "up")}
                    >
                      Move Up
                    </button>
                    <button
                      type="button"
                      disabled={mutatingStructure || categories.findIndex(c => c.id === renameCategoryId) === categories.length - 1}
                      onClick={() => moveCategoryPosition(renameCategoryId, "down")}
                    >
                      Move Down
                    </button>
                  </div>
                </div>

                <div className="stack" style={{ borderTop: "1px solid var(--border)", paddingTop: "1rem" }}>
                  <p>Danger Zone</p>
                  <button
                    type="button"
                    className="danger"
                    disabled={mutatingStructure}
                    onClick={() => {
                      const cat = categories.find(c => c.id === renameCategoryId);
                      if (confirm(`Are you sure you want to delete the category "${cat?.name}"? Rooms inside will become uncategorized.`)) {
                        void handleDeleteCategory(renameCategoryId);
                        dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
                      }
                    }}
                  >
                    Delete Category
                  </button>
                </div>
              </div>
            )}

            {activeModal === "create-room" && (
              <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                void handleCreateRoom(event);
                dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
              }}>
                <p>
                  Target Category: <strong>
                    {selectedCategoryIdForCreate ? categories.find(c => c.id === selectedCategoryIdForCreate)?.name : "Uncategorized"}
                  </strong>
                </p>
                <label htmlFor="room-name-modal">Room Name</label>
                <input
                  id="room-name-modal"
                  autoFocus
                  value={roomName}
                  onChange={(e) => setRoomName(e.target.value)}
                  minLength={2}
                  maxLength={80}
                  required
                />
                <label htmlFor="room-type-modal">Type</label>
                <select id="room-type-modal" value={roomType} onChange={(e) => setRoomType(e.target.value as any)}>
                  <option value="text">Text Room</option>
                  <option value="announcement">Announcement Room</option>
                  <option value="voice">Voice Room</option>
                </select>
                <button type="submit" disabled={creatingRoom}>Create Room</button>
              </form>
            )}

            {activeModal === "rename-room" && (
              <div className="stack">
                <form className="stack" onSubmit={(event: React.FormEvent<HTMLFormElement>) => {
                  void handleRenameRoom(event);
                  dispatch({ type: "SET_ACTIVE_MODAL", payload: null });
                }}>
                  <p>Editing room: <strong>{channels.find(c => c.id === renameRoomId)?.name}</strong></p>
                  <label htmlFor="rename-room-modal">Room Name</label>
                  <input
                    id="rename-room-modal"
                    autoFocus
                    value={renameRoomName}
                    onChange={(e) => dispatch({ type: "SET_RENAME_ROOM", payload: { id: renameRoomId, name: e.target.value, type: renameRoomType, categoryId: renameRoomCategoryId } })}
                    minLength={2}
                    maxLength={80}
                    required
                  />

                  <label htmlFor="rename-room-type">Type</label>
                  <select
                    id="rename-room-type"
                    value={renameRoomType}
                    onChange={(e) => dispatch({ type: "SET_RENAME_ROOM", payload: { id: renameRoomId, name: renameRoomName, type: e.target.value as any, categoryId: renameRoomCategoryId } })}
                  >
                    <option value="text">Text Room</option>
                    <option value="announcement">Announcement Room</option>
                    <option value="voice">Voice Room</option>
                  </select>

                  <label htmlFor="rename-room-category">Category</label>
                  <select
                    id="rename-room-category"
                    value={renameRoomCategoryId ?? ""}
                    onChange={(e) => dispatch({ type: "SET_RENAME_ROOM", payload: { id: renameRoomId, name: renameRoomName, type: renameRoomType, categoryId: e.target.value || null } })}
                  >
                    <option value="">(None)</option>
                    {categories.map(c => (
                      <option key={c.id} value={c.id}>{c.name}</option>
                    ))}
                  </select>

                  <button type="submit" disabled={mutatingStructure}>Save Changes</button>
                </form>

                <div className="stack" style={{ borderTop: "1px solid var(--border)", paddingTop: "1rem" }}>
                  <p>Reorder Room</p>
                  <div style={{ display: "flex", gap: "0.5rem" }}>
                    <button
                      type="button"
                      disabled={mutatingStructure || (() => {
                        const channel = channels.find(c => c.id === renameRoomId);
                        if (!channel) return true;
                        const peers = channels.filter(c => c.categoryId === channel.categoryId)
                          .sort((a, b) => a.position - b.position || a.createdAt.localeCompare(b.createdAt));
                        return peers.findIndex(c => c.id === renameRoomId) === 0;
                      })()}
                      onClick={() => moveChannelPosition(renameRoomId, "up")}
                    >
                      Move Up
                    </button>
                    <button
                      type="button"
                      disabled={mutatingStructure || (() => {
                        const channel = channels.find(c => c.id === renameRoomId);
                        if (!channel) return true;
                        const peers = channels.filter(c => c.categoryId === channel.categoryId)
                          .sort((a, b) => a.position - b.position || a.createdAt.localeCompare(b.createdAt));
                        return peers.findIndex(c => c.id === renameRoomId) === peers.length - 1;
                      })()}
                      onClick={() => moveChannelPosition(renameRoomId, "down")}
                    >
                      Move Down
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </main>
  );
}
